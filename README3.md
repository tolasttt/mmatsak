Алгоритмы сортировки

Сортировка выбором (Selection Sort)

Алгоритм последовательно находит минимальный элемент в неотсортированной части массива и переносит его в начало отсортированной области.

Как это устроено: внешний цикл перебирает позиции от первой до предпоследней; во внутреннем цикле ищется индекс минимума справа от текущей позиции, затем выполняется обмен с элементом на позиции i. Повторяем, пока массив не станет отсортирован.

Пример
Исходные данные: 64 25 12 22 11
Результат: 11 12 22 25 64

Сложность: O(n²) — в лучшем, среднем и худшем случаях.


Сортировка обменом (Bubble Sort)

Многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят неверно. Крупные значения «всплывают» к концу.

Идея: каждый внешний проход сокращает проверяемый хвост; внутренний цикл сравнивает пары соседей. Флаг swapped позволяет завершить работу ранее, если за проход не было перестановок.

Пример для {64, 34, 25, 12, 22, 11}:
    1.    {34, 25, 12, 22, 11, 64} →
    2.    {25, 12, 22, 11, 34, 64} →
    3.    {12, 22, 11, 25, 34, 64} →
    4.    {12, 11, 22, 25, 34, 64} →
    5.    {11, 12, 22, 25, 34, 64}

Сложность: O(n²) в среднем/худшем; в лучшем (уже отсортировано, есть оптимизация) — O(n).


Сортировка вставками (Insertion Sort)

Постепенно формирует слева отсортированную часть и «вставляет» каждый новый элемент на корректную позицию внутри неё.

Ход работы: берём ключ из неотсортированной части, сдвигаем в отсортированной все элементы, которые больше ключа, затем ставим ключ на освободившееся место.

Пример для {12, 11, 13, 5, 6}:
→ {11, 12, 13, 5, 6} → {11, 12, 13, 5, 6} → {5, 11, 12, 13, 6} → {5, 6, 11, 12, 13}

Сложность: средний/худший — O(n²); лучший — O(n) (почти отсортировано).


Сортировка слиянием (Merge Sort)

Рекурсивный алгоритм «разделяй и властвуй»: делит массив пополам, сортирует каждую половину и сливает их в один отсортированный массив.

Этапы: рекурсивное деление до единичных элементов → поэтапное слияние отсортированных фрагментов.

Пример для {38, 27, 43, 3, 9, 82, 10}: дробим, сортируем подмассивы и объединяем их в итоговую упорядоченную последовательность.

Сложность: O(n log n) во всех случаях; нужна доп. память под слияние.


Сортировка Шелла (Shell Sort)

Ускоренная версия вставок: сначала упорядочивает элементы на больших расстояниях (gap), затем уменьшает gap до 1 и завершает обычными вставками.

Схема: выбрать начальный gap (например, n/2), выполнить «вставки» для элементов на расстоянии gap, уменьшить gap и повторить.

Пример для {23, 12, 1, 8, 34, 56, 7}: при gap = 3 частично упорядочиваем подпоследовательности; при gap = 1 доводим порядок вставками → итог: {1, 7, 8, 12, 23, 34, 56}.

Сложность: зависит от интервалов: на практике ≈ O(n^{1.25}…n^{1.5}); в худшем — до O(n²); для удачных последовательностей — близко к O(n log n).


Быстрая сортировка (Quicksort)

Выбирает опорный элемент (pivot), переупорядочивает массив на «меньше/больше pivot», затем рекурсивно сортирует получившиеся части.

Процесс: выбор pivot → разбиение → рекурсия до подмассивов длины 1.

Пример для {10, 7, 8, 9, 1, 5}: pivot = 5 → разбиение → вставляем pivot на позицию → рекурсивно сортируем левую и правую стороны.

Сложность: средний/лучший — O(n log n); худший — O(n²) (неудачные опоры). Память по стеку — в среднем O(log n).


Пирамидальная сортировка (Heapsort)

Использует бинарную кучу (max-heap): строит кучу, затем многократно меняет корень с последним элементом и «просеивает» корень вниз.

Структура: heapSort — основная логика; heapify — поддержание свойства кучи; swap — обмен.

Пример для [12, 11, 13, 5, 6, 7]: строим max-heap → по одному переносим максимум в конец → получаем [5, 6, 7, 11, 12, 13].

Сложность: построение — O(n); извлечения — O(n log n); итого — O(n log n). Память — O(1).


Алгоритмы поиска

Последовательный (линейный) поиск

Перебирает элементы слева направо, пока не найдёт целевой или не дойдёт до конца.

Пример: для {3, 8, 1, 10, 5} поиск 10 вернёт индекс 3.

Сложность: лучший — O(1); средний/худший — O(n).


Бинарный поиск

Работает на отсортированном массиве: сравнивает середину с целью и на каждом шаге делит диапазон пополам.

Пример: в [1, 3, 5, 7, 9, 11] число 7 находится за две итерации.

Сложность: лучший — O(1); средний/худший — O(log n).


Интерполирующий поиск

Для отсортированных и равномерно распределённых данных оценивает позицию цели по формуле интерполяции, а не берёт середину.

Формула позиции:
pos = low + (high - low) * (target - a[low]) / (a[high] - a[low])

Пример: в [10, 15, 20, 25, 30, 35, 40, 45, 50] для 35 оценка быстро приводит к точному индексу.

Сложность: лучший — O(1); средний — O(log log n); худший — до O(n) (при неравномерном распределении).


Поиск Фибоначчи

Вариант бинарного поиска на отсортированном массиве: границы шага выбираются по числам Фибоначчи.

Идея: берём минимальное число Фибоначчи ≥ n, затем шагами Фибоначчи уточняем позицию до попадания или исчерпания диапазона.

Пример: для [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100] и цели 85 алгоритм даёт индекс 8.

Сложность: лучший — O(1); средний/худший — порядка O(log n) (близко к O(log_φ n)).
