**Вариант 18. Реализуйте DFS для графа с выводом времени входа и выхода для каждой
вершины.**

**Как работает алгоритм** - Сортировка слиянием (Merge Sort).

1.	Проверяем базовый случай: если диапазон длиной 0 или 1, возвращаем как есть (if r - l <= 1: return)
	2.	Находим середину диапазона (mid = (l + r) // 2)
	3.	Рекурсивно сортируем левую половину (merge_sort(a, l, mid))
	4.	Рекурсивно сортируем правую половину (merge_sort(a, mid, r))
	5.	Готовим временный буфер нужного размера (tmp = [0] * (r - l))
	6.	Инициализируем индексы для слияния (i, j, k = l, mid, 0)
	7.	Запускаем основной цикл слияния, пока есть элементы в обеих половинах (while i < mid and j < r:)
	8.	Сравниваем текущие элементы левой и правой половин (if a[i] <= a[j]:)
	9.	Записываем выбранный элемент в буфер (tmp[k] = a[i] if a[i] <= a[j] else a[j])
	10.	Продвигаем соответствующие указатели и индекс буфера (i += (a[i] <= a[j]); j += (a[i] > a[j]); k += 1)
	11.	После исчерпания одной половины дописываем хвост второй (tmp[k:] = a[i:mid] + a[j:r])
	12.	Копируем отсортированный отрезок обратно в исходный массив (a[l:r] = tmp)
	13.	Возвращаем управление вызывающему уровню (return)

Сортировка слиянием делит массив на две половины до единичных элементов, рекурсивно упорядочивает их и сливает обратно; ключевое действие — на каждом шаге взять меньший из двух текущих элементов отсортированных половин и добавить в результат (см. строку выше); время O(n log n), слияние на каждом уровне даёт суммарно O(n), глубина уровней ≈ log n; алгоритм устойчивый, но требует дополнительный буфер O(n).

**Формат ввода/вывода**

Ввод
n m
u1 v1
u2 v2
...
um vm
Вершины — 1..n.

**Вывод**
Для каждой вершины v: v: tin[v] tout[v].


**Пример**

**Ввод**
5 4
1 2
1 3
2 4
3 5

**Вывод**
1: 1 10
2: 2 5
3: 6 9
4: 3 4
5: 7 8

**Временная сложность:O(n log n) **

Временная сложность базового обхода в глубину равна O(n + m), где n — число вершин, m — число рёбер. Каждая вершина помечается один раз, каждое ребро просматривается фиксированное число раз; в неориентированном графе ребро учитывается дважды без изменения асимптотики. Если перед запуском отсортировать списки смежности для стабильного порядка обхода, подготовительный этап занимает O(m log m), при этом сам DFS остаётся O(n + m).


Вопрос номер 5. Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием


Стратегия «разделяй и властвуй» предлагает решать задачу, сначала разрезав её на несколько меньших, затем решив каждую из них тем же методом и, наконец, объединив частные ответы в общий. На сортировке слиянием это видно особенно ясно. Имеется массив из n элементов. Если его длина не превышает единицы, он уже упорядочен и возвращается без работы. Если элементов больше, массив делят на две примерно равные части, рекурсивно упорядочивают каждую из них, а затем выполняют слияние двух уже отсортированных половин в один отсортированный массив. Слияние устроено предельно просто: берутся два «указателя» на начала половин, на каждом шаге сравниваются текущие элементы и меньший переносится в результирующее место; указатель соответствующей половины двигается вперёд, а когда одна из частей заканчивается, оставшаяся часть целиком дописывается в конец результата. Такая процедура работает за линейное время относительно суммарной длины половин и сохраняет устойчивость упорядочивания, потому что равные элементы из левой части всегда попадают в результат раньше равных элементов из правой.

Корректность метода опирается на индуктивный взгляд: рекурсивные вызовы возвращают две отсортированные последовательности, а инвариант слияния гласит, что уже собранный префикс результата остаётся отсортированным и состоит из наименьших из ещё не перенесённых элементов обеих половин; поскольку на каждом шаге выбирается минимум из двух текущих кандидатов, после исчерпания обеих частей в результате получается полностью отсортированный массив.

Трудоёмкость удобно описать рекуррентным соотношением. Время на сортировку массива длины n равно времени на две сортировки длины n/2 плюс линейное время на одно слияние, что записывается как T(n) = 2·T(n/2) + c·n. Решение этой рекуррентности даёт T(n) = Θ(n log n): глубина рекурсии пропорциональна log n, а на каждом «уровне» суммарная стоимость всех слияний равна n, поэтому итог складывается в n умножить на число уровней. Это верно для любого исходного распределения значений, так что лучшая, средняя и худшая оценки совпадают по порядку. Памятью алгоритм пользуется дополнительной: для массивной реализации обычно нужен вспомогательный буфер размером порядка n под результат каждого слияния; кроме этого, присутствует стек рекурсии глубины порядка log n, а у итеративного (bottom-up) варианта рекурсия заменяется последовательными проходами по массиву с удвоением размера «блоков» и той же асимптотикой по времени и памяти. Важное практическое следствие — слияние читает данные последовательно, благодаря чему сортировка слиянием хорошо подходит для внешней сортировки на дисках и потоках, где последовательный доступ значительно дешевле случайного.
