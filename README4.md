Как работает алгоритм

Обход в глубину строит дерево рекурсии и фиксирует два момента для каждой вершины: время входа и время выхода. В начале вводится общий счётчик, который увеличивается на единицу при каждом значимом событии. Когда алгоритм впервые заходит в вершину, счётчик увеличивается, и это значение записывается как время входа. Затем последовательно просматриваются соседи, и для каждого соседа, который ещё не посещён, выполняется погружение глубже. Когда все переходы из текущей вершины завершены, счётчик снова увеличивается, а полученное значение становится временем выхода. Такой порядок гарантирует, что отрезок от времени входа до времени выхода для предка всегда полностью покрывает отрезки его потомков. Это свойство удобно для быстрого определения отношения «предок–потомок» с помощью простой проверки нестрогих неравенств: у предка время входа меньше, а время выхода больше, чем у потомка, а сама вершина считается «активной» на всём промежутке между этими двумя метками.

Практическая реализация использует массив пометок посещения, чтобы исключить повторные визиты, и списки смежности для хранения графа. Порядок обхода соседей влияет только на конкретные числа меток, но не на их относительную структуру. Если требуется стабильный порядок, перед запуском удобно отсортировать списки смежности, после чего результат будет воспроизводимым при каждом запуске.

По трудоёмкости алгоритм линейный относительно размера входа. Каждая вершина обрабатывается один раз, каждое ребро рассматривается константное число раз, поэтому суммарное время равно O(n + m), где n — число вершин, m — число рёбер. Дополнительная память уходит на списки смежности и рабочие массивы с метками и флагами, а также на стек рекурсии; в сумме это оценивается как O(n + m) по структурам данных и O(n) по глубине вызовов в худшем случае. Если перед запуском отсортировать соседей для детерминизма, появляется подготовительный этап порядка O(m log m), при этом сам обход сохраняет линейную сложность.


Формат ввода/вывода

Ввод
n m
u1 v1
u2 v2
...
um vm
Вершины — 1..n.

Вывод
Для каждой вершины v: v: tin[v] tout[v].


Пример

Ввод
5 4
1 2
1 3
2 4
3 5

Вывод
1: 1 10
2: 2 5
3: 6 9
4: 3 4
5: 7 8

временная сложность:

Временная сложность базового обхода в глубину равна O(n + m), где n — число вершин, m — число рёбер. Каждая вершина помечается один раз, каждое ребро просматривается фиксированное число раз; в неориентированном графе ребро учитывается дважды без изменения асимптотики. Если перед запуском отсортировать списки смежности для стабильного порядка обхода, подготовительный этап занимает O(m log m), при этом сам DFS остаётся O(n + m).


Вопрос номер 5. Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием

Стратегия «разделяй и властвуй» предлагает решать задачу, сначала разрезав её на несколько меньших, затем решив каждую из них тем же методом и, наконец, объединив частные ответы в общий. На сортировке слиянием это видно особенно ясно. Имеется массив из n элементов. Если его длина не превышает единицы, он уже упорядочен и возвращается без работы. Если элементов больше, массив делят на две примерно равные части, рекурсивно упорядочивают каждую из них, а затем выполняют слияние двух уже отсортированных половин в один отсортированный массив. Слияние устроено предельно просто: берутся два «указателя» на начала половин, на каждом шаге сравниваются текущие элементы и меньший переносится в результирующее место; указатель соответствующей половины двигается вперёд, а когда одна из частей заканчивается, оставшаяся часть целиком дописывается в конец результата. Такая процедура работает за линейное время относительно суммарной длины половин и сохраняет устойчивость упорядочивания, потому что равные элементы из левой части всегда попадают в результат раньше равных элементов из правой.

Корректность метода опирается на индуктивный взгляд: рекурсивные вызовы возвращают две отсортированные последовательности, а инвариант слияния гласит, что уже собранный префикс результата остаётся отсортированным и состоит из наименьших из ещё не перенесённых элементов обеих половин; поскольку на каждом шаге выбирается минимум из двух текущих кандидатов, после исчерпания обеих частей в результате получается полностью отсортированный массив.

Трудоёмкость удобно описать рекуррентным соотношением. Время на сортировку массива длины n равно времени на две сортировки длины n/2 плюс линейное время на одно слияние, что записывается как T(n) = 2·T(n/2) + c·n. Решение этой рекуррентности даёт T(n) = Θ(n log n): глубина рекурсии пропорциональна log n, а на каждом «уровне» суммарная стоимость всех слияний равна n, поэтому итог складывается в n умножить на число уровней. Это верно для любого исходного распределения значений, так что лучшая, средняя и худшая оценки совпадают по порядку. Памятью алгоритм пользуется дополнительной: для массивной реализации обычно нужен вспомогательный буфер размером порядка n под результат каждого слияния; кроме этого, присутствует стек рекурсии глубины порядка log n, а у итеративного (bottom-up) варианта рекурсия заменяется последовательными проходами по массиву с удвоением размера «блоков» и той же асимптотикой по времени и памяти. Важное практическое следствие — слияние читает данные последовательно, благодаря чему сортировка слиянием хорошо подходит для внешней сортировки на дисках и потоках, где последовательный доступ значительно дешевле случайного.
