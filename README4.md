Как работает алгоритм

Обход в глубину строит дерево рекурсии и фиксирует два момента для каждой вершины: время входа и время выхода. В начале вводится общий счётчик, который увеличивается на единицу при каждом значимом событии. Когда алгоритм впервые заходит в вершину, счётчик увеличивается, и это значение записывается как время входа. Затем последовательно просматриваются соседи, и для каждого соседа, который ещё не посещён, выполняется погружение глубже. Когда все переходы из текущей вершины завершены, счётчик снова увеличивается, а полученное значение становится временем выхода. Такой порядок гарантирует, что отрезок от времени входа до времени выхода для предка всегда полностью покрывает отрезки его потомков. Это свойство удобно для быстрого определения отношения «предок–потомок» с помощью простой проверки нестрогих неравенств: у предка время входа меньше, а время выхода больше, чем у потомка, а сама вершина считается «активной» на всём промежутке между этими двумя метками.

Практическая реализация использует массив пометок посещения, чтобы исключить повторные визиты, и списки смежности для хранения графа. Порядок обхода соседей влияет только на конкретные числа меток, но не на их относительную структуру. Если требуется стабильный порядок, перед запуском удобно отсортировать списки смежности, после чего результат будет воспроизводимым при каждом запуске.

По трудоёмкости алгоритм линейный относительно размера входа. Каждая вершина обрабатывается один раз, каждое ребро рассматривается константное число раз, поэтому суммарное время равно O(n + m), где n — число вершин, m — число рёбер. Дополнительная память уходит на списки смежности и рабочие массивы с метками и флагами, а также на стек рекурсии; в сумме это оценивается как O(n + m) по структурам данных и O(n) по глубине вызовов в худшем случае. Если перед запуском отсортировать соседей для детерминизма, появляется подготовительный этап порядка O(m log m), при этом сам обход сохраняет линейную сложность.


Формат ввода/вывода

Ввод
n m
u1 v1
u2 v2
...
um vm
Вершины — 1..n.

Вывод
Для каждой вершины v: v: tin[v] tout[v].


Пример

Ввод
5 4
1 2
1 3
2 4
3 5

Вывод
1: 1 10
2: 2 5
3: 6 9
4: 3 4
5: 7 8

временная сложность:

Временная сложность базового обхода в глубину равна O(n + m), где n — число вершин, m — число рёбер. Каждая вершина помечается один раз, каждое ребро просматривается фиксированное число раз; в неориентированном графе ребро учитывается дважды без изменения асимптотики. Если перед запуском отсортировать списки смежности для стабильного порядка обхода, подготовительный этап занимает O(m log m), при этом сам DFS остаётся O(n + m).
