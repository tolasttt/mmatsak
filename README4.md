Как работает алгоритм

1.	Проверяем базовый случай: если диапазон длиной 0 или 1, завершаем и возвращаем его как есть (оператор: if).
	2.	Находим середину диапазона: mid = (l + r) // 2 (оператор: //).
	3.	Рекурсивно сортируем левую половину: merge_sort(a, l, mid) (оператор: () — вызов функции).
	4.	Рекурсивно сортируем правую половину: merge_sort(a, mid, r) (оператор: () — вызов функции).
	5.	Готовим временный буфер нужного размера для результата слияния (оператор: new / создание массива).
	6.	Инициализируем индексы для слияния: i = l, j = mid, k = 0 (оператор: =).
	7.	Выполняем основной цикл слияния, пока элементы есть в обеих половинах (оператор: while).
	8.	Сравниваем текущие элементы левой и правой половин, выбираем меньший (оператор: <=).
	9.	Записываем выбранный элемент в буфер на позицию k (оператор: =).
	10.	Продвигаем соответствующий указатель источника и индекс буфера (оператор: ++ / += 1).
	11.	Когда одна половина исчерпана, дозаписываем «хвост» второй половины в буфер (оператор: copy).
	12.	Копируем содержимое буфера обратно в исходный массив на позиции a[l:r] (оператор: = для присваивания среза).
	13.	Возвращаем управление вызывающему уровню рекурсии (оператор: return).


Формат ввода/вывода

Ввод
n m
u1 v1
u2 v2
...
um vm
Вершины — 1..n.

Вывод
Для каждой вершины v: v: tin[v] tout[v].


Пример

Ввод
5 4
1 2
1 3
2 4
3 5

Вывод
1: 1 10
2: 2 5
3: 6 9
4: 3 4
5: 7 8

временная сложность:

Временная сложность базового обхода в глубину равна O(n + m), где n — число вершин, m — число рёбер. Каждая вершина помечается один раз, каждое ребро просматривается фиксированное число раз; в неориентированном графе ребро учитывается дважды без изменения асимптотики. Если перед запуском отсортировать списки смежности для стабильного порядка обхода, подготовительный этап занимает O(m log m), при этом сам DFS остаётся O(n + m).


Вопрос номер 5. Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием

Стратегия «разделяй и властвуй» предлагает решать задачу, сначала разрезав её на несколько меньших, затем решив каждую из них тем же методом и, наконец, объединив частные ответы в общий. На сортировке слиянием это видно особенно ясно. Имеется массив из n элементов. Если его длина не превышает единицы, он уже упорядочен и возвращается без работы. Если элементов больше, массив делят на две примерно равные части, рекурсивно упорядочивают каждую из них, а затем выполняют слияние двух уже отсортированных половин в один отсортированный массив. Слияние устроено предельно просто: берутся два «указателя» на начала половин, на каждом шаге сравниваются текущие элементы и меньший переносится в результирующее место; указатель соответствующей половины двигается вперёд, а когда одна из частей заканчивается, оставшаяся часть целиком дописывается в конец результата. Такая процедура работает за линейное время относительно суммарной длины половин и сохраняет устойчивость упорядочивания, потому что равные элементы из левой части всегда попадают в результат раньше равных элементов из правой.

Корректность метода опирается на индуктивный взгляд: рекурсивные вызовы возвращают две отсортированные последовательности, а инвариант слияния гласит, что уже собранный префикс результата остаётся отсортированным и состоит из наименьших из ещё не перенесённых элементов обеих половин; поскольку на каждом шаге выбирается минимум из двух текущих кандидатов, после исчерпания обеих частей в результате получается полностью отсортированный массив.

Трудоёмкость удобно описать рекуррентным соотношением. Время на сортировку массива длины n равно времени на две сортировки длины n/2 плюс линейное время на одно слияние, что записывается как T(n) = 2·T(n/2) + c·n. Решение этой рекуррентности даёт T(n) = Θ(n log n): глубина рекурсии пропорциональна log n, а на каждом «уровне» суммарная стоимость всех слияний равна n, поэтому итог складывается в n умножить на число уровней. Это верно для любого исходного распределения значений, так что лучшая, средняя и худшая оценки совпадают по порядку. Памятью алгоритм пользуется дополнительной: для массивной реализации обычно нужен вспомогательный буфер размером порядка n под результат каждого слияния; кроме этого, присутствует стек рекурсии глубины порядка log n, а у итеративного (bottom-up) варианта рекурсия заменяется последовательными проходами по массиву с удвоением размера «блоков» и той же асимптотикой по времени и памяти. Важное практическое следствие — слияние читает данные последовательно, благодаря чему сортировка слиянием хорошо подходит для внешней сортировки на дисках и потоках, где последовательный доступ значительно дешевле случайного.
